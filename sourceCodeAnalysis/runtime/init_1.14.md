# 初始化

## 1. 引导
通过编译程序确认入口(entry point)。

> 使用info files 获取入口地址，随后 b addres插入断点。 

```
(gdb) info files
Symbols from "/home/go/go.test/src/main".
Local exec file:
	`/home/go/go.test/src/main', file type elf64-x86-64.
	Entry point: 0x45c130
	0x0000000000401000 - 0x0000000000635600 is .text
	0x0000000000635600 - 0x0000000000635810 is .plt
	0x0000000000636000 - 0x000000000072fcba is .rodata
	0x00000000007305a0 - 0x0000000000730918 is .dynsym
	0x000000000072fcc0 - 0x000000000072fcd8 is .rela
	0x000000000072fcd8 - 0x000000000072ffd8 is .rela.plt
	0x000000000072ffe0 - 0x000000000073002a is .gnu.version
	0x0000000000730040 - 0x0000000000730090 is .gnu.version_r
	0x00000000007300a0 - 0x0000000000730158 is .hash
	0x0000000000730380 - 0x0000000000730593 is .dynstr
	0x0000000000730920 - 0x000000000073297c is .typelink
	0x0000000000732980 - 0x0000000000733108 is .itablink
	0x0000000000733108 - 0x0000000000733108 is .gosymtab
	0x0000000000733120 - 0x0000000000893d7e is .gopclntab
	0x0000000000894000 - 0x0000000000894020 is .go.buildinfo
	0x0000000000894020 - 0x0000000000894138 is .got.plt
	0x0000000000894140 - 0x0000000000894270 is .dynamic
	0x0000000000894270 - 0x0000000000894278 is .got
	0x0000000000894280 - 0x00000000008c8620 is .noptrdata
	0x00000000008c8620 - 0x00000000008d2690 is .data
	0x00000000008d26a0 - 0x00000000008f0730 is .bss
	0x00000000008f0740 - 0x00000000008f3be8 is .noptrbss
	0x0000000000000000 - 0x0000000000000008 is .tbss
	0x0000000000400fe4 - 0x0000000000401000 is .interp
	0x0000000000400f80 - 0x0000000000400fe4 is .note.go.buildid
```

```
// rt0_linux_amd64.s

TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8
	JMP	_rt0_amd64(SB)
```

```
// asm_amd64.s

TEXT _rt0_amd64(SB),NOSPLIT,$-8
	MOVQ	0(SP), DI	// argc
	LEAQ	8(SP), SI	// argv
	JMP	runtime·rt0_go(SB)
```

```

TEXT runtime·rt0_go(SB),NOSPLIT,$0
	// ...

	CALL	runtime·args(SB)
	CALL	runtime·osinit(SB)
	CALL	runtime·schedinit(SB)

	/*
		// create a new goroutine to start program
		MOVQ	$runtime·mainPC(SB), AX		// entry
		PUSHQ	AX
		PUSHQ	$0			// arg size
		CALL	runtime·newproc(SB)
		POPQ	AX
		POPQ	AX
	*/
	runtime.main()

	// start this M
	CALL	runtime·mstart(SB)
```

```
DATA	runtime·mainPC+0(SB)/8,$runtime·main(SB)
GLOBL	runtime·mainPC(SB),RODATA,$8
```

创建main goroutine(runtime.main)，调用M.mstart 让主线程进入调度(schedule)循环。

## 2. 初始化
在引导过程中，先调用了：

* runtime.args
* runtime.osinit
* runtime.schedinit

然后调用main goroutine(runtime.main)执行。

### osinit

```
func osinit() {
	// 逻辑处理器数量
	ncpu = getproccount()
}
```

```
// runtime2.go
var ncpu int32
```

标准库 runtime.NumCPU就是返回该变量值。

```
// debug.go

// NumCPU returns the number of logical CPUs usable by the current process.

func NumCPU() int {
	return int(ncpu)
}
```

### schedinit

```
// proc.go

// call osinit
// call schedinit
// make & queue new G
// call runtime.mstart
//
// The new G calls runtime.main.

func schedinit() {

	// M 默认最大值
	sched.maxmcount = 10000


	// 检查shared library、Plugin 哈希值。如果不符,会引发ABI mismatch错误。
	moduledataverify()

	// 内存相关初始化
	stackinit()
	mallocinit()

	// 初始化当前M
	mcommoninit(_g_.m)


	msigsave(_g_.m)
	initSigmask = _g_.m.sigmask

	// 处理参数、环境变量(包括GODEBUG、GOTRACEBACK)
	goargs()
	goenvs()
	parsedebugvars()

	// 垃圾回收初始化
	gcinit()

	// 初始化poll事件(sysmon会用)
	sched.lastpoll = uint64(nanotime())

	// GOMAXPROCS设置
	procs := ncpu
	if n, ok := atoi32(gogetenv("GOMAXPROCS")); ok && n > 0 {
		procs = n
	}
	if procresize(procs) != nil {
		throw("unknown runnable goroutine during bootstrap")
	}
}
```

> 从 1.10起, 取消了GOMAXPROCESS 256 限制。

### runtime.main

$runtime.mainPC存储runtime.main，通过GDB定位runtime.mainPC存储内容。

```
(gdb) x/2xg 0x71a7f0
0x71a7f0 <runtime.mainPC>:	0x000000000042fff0	0x0000000000000002
(gdb) x/xg 0x000000000042fff0
0x42fff0 <runtime.main>:	0xfffff8250c8b4864
```

```
// The main goroutine.
func main() {

	// G.stack 最大1GB
	if sys.PtrSize == 8 {
		maxstacksize = 1000000000
	} else {
		maxstacksize = 250000000
	}

	// main.G 启动标志,允许启动新的M
	mainStarted = true


	// 启动系统监控
	newm(sysmon, nil)

	// 执行runtime包初始化函数
	doInit(&runtime_inittask)


	// 初始化时间
	runtimeInitTime = nanotime()

	// 启动垃圾回收器
	gcenable()


	// 动态库模式，不执行入口函数
	if isarchive || islibrary {
		// A program compiled with -buildmode=c-archive or c-shared
		// has a main, but it is not executed.
		return
	}

	// 执行main.main 用户入口函数
	fn := main_main
	fn()
	if raceenabled {
		racefini()
	}

	// 退出
	exit(0)
}
```

> 相比 1.12 自动生成(autogenerated) runtime.init、main.init函数，1.13改为doInit 执行模式。

每个Package持有一个initTask结构。

```
// proc.go 

// An initTask represents the set of initializations that need to be done for a package.
// Keep in sync with ../../test/initempty.go:initTask
type initTask struct {
	state uintptr 		// 0 = uninitialized, 1 = in progress, 2 = done
	ndeps uintptr 
	nfns  uintptr 
}
```

按依赖关系，为每个包收集所有初始化函数。并以两个全局变量构成链式结构。

```
 //go:linkname runtime_inittask runtime..inittask
 var runtime_inittask initTask
 
 //go:linkname main_inittask main..inittask
 var main_inittask initTask
```

例如:

```
// main.go

package main

import (
        _ "net/http"
        "test/mylib"
)

func init() {
        println(1)
}

func init() {
        println(2)
}

func main() {
        mylib.Hello()
}
```

```
// test/mylib/mylib.go

package mylib

func init() {
        println(1)
}

func Hello() {
        println(0x64)
}
```

```
+-------------------+                    +-------------------+                               
|                   |                    |                   |                               
|   main..inittask  |         +--------->| net/http.inittask |                               
|                   |         |          |                   |                               
+-------------------+         |          +-------------------+                               
|                   |         |          |                   |                               
|      state        |         |          |       state       |                               
+-------------------+         |          |                   |                               
|                   |         |          +-------------------+                               
|     ndeps = 2     |         |          |                   |                               
|                   |         |          |      ndeps        |                               
+-------------------+         |          |                   |                               
|                   |         |          +-------------------+                               
|     nfns = 2      |         |          |                   |                               
|                   |         |          |      nfns         |                               
+-------------------+         |          +-------------------+                               
|                   |         |          |                   |                               
|*net/http.inittask +---------+          |       ...         |                               
|                   |                    |                   |                               
+-------------------+                    +-------------------+                               
|                   |                                                                        
|  *mylib.inittask  +------------------------+                                               
|                   |                        |                                               
+-------------------+                        |                                               
|                   |                        |                                               
|  *main.init.0     |                        |                                               
|                   |                        |                                               
+-------------------+                        |                                               
|                   |                        |                          +-------------------+
|                   |                        |                          |                   |
|  *main.init.1     |                        +------------------------> |mylib/http.inittask|
|                   |                                                   |                   |
+-------------------+                                                   +-------------------+
                                                                        |                   |
                                                                        |       state       |
                                                                        |                   |
                                                                        +-------------------+
                                                                        |                   |
                                                                        |    ndeps = 0      |
                                                                        |                   |
                                                                        +-------------------+
                                                                        |                   |
                                                                        |      nfns = 1     |
                                                                        +-------------------+
                                                                        |                   |
                                                                        |  *mylib.init.0    |
                                                                        |                   |
                                                                        +-------------------+
```

> 通过编译器或调试器观察InitTask数据。
> 多个 init 会添加数字后缀，比如 `runtime.init.1`，如此才允许有多个同名函数存在。

```
$ go build -gcflags "-l -m -S" 2>a.txt

""..inittask SNOPTRDATA size=56
        0x0000 00 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00  ................
        0x0010 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
        0x0020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
        0x0030 00 00 00 00 00 00 00 00                          ........
        rel 24+8 t=1 net/http..inittask+0
        rel 32+8 t=1 test/mylib..inittask+0
        rel 40+8 t=1 "".init.0+0
        rel 48+8 t=1 "".init.1+0

```

```
$ go build -gcflags "-l -m -S" test/mylib 2>b.txt

""..inittask SNOPTRDATA size=32
        0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
        0x0010 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
        rel 24+8 t=1 "".init.0+0
```

```
(gdb) b runtime.main
(gdb) r

(gdb) info address main..inittask
Symbol "main..inittask" is static storage at address 0x896d20.
(gdb) b runtime.doInit if t=0x896d20
Breakpoint 2 at 0x43c180: file /usr/local/go/src/runtime/proc.go, line 5206.

(gdb) c
Continuing.
[New Thread 0x7ffff55df700 (LWP 2085)]

Thread 1 "main" hit Breakpoint 2, runtime.doInit (t=0x896d20 <main..inittask>) at /usr/local/go/src/runtime/proc.go:5206
5206	func doInit(t *initTask) {

(gdb) p *t
$1 = {state = 0, ndeps = 2, nfns = 2}


(gdb) x/8xg t
0x896d20 <main..inittask>:	0x0000000000000000	0x0000000000000002
0x896d30 <main..inittask+16>:	0x0000000000000002	0x000000000089c060
0x896d40 <main..inittask+32>:	0x0000000000895500	0x0000000000635530
0x896d50 <main..inittask+48>:	0x0000000000635580	0x0000000000000000

(gdb) info symbol 0x000000000089c060
net/http..inittask in section .noptrdata of /home/go/go.test/src/main

(gdb) info symbol 0x0000000000895500
test/mylib..inittask in section .noptrdata of /home/go/go.test/src/main

(gdb) info symbol 0x0000000000635530
main.init in section .text of /home/go/go.test/src/main

(gdb) info symbol 0x0000000000635580
main.init in section .text of /home/go/go.test/src/main

(gdb) x/4xg 0x0000000000895500
0x895500 <test/mylib..inittask>:	0x0000000000000000	0x0000000000000000
0x895510 <test/mylib..inittask+16>:	0x0000000000000001	0x0000000000635490

(gdb) info symbol 0x0000000000635490
test/mylib.init in section .text of /home/go/go.test/src/main
```

如此，doInit就可以递归遍历，执行所有初始化函数。且确保被依赖包优先执行。

```
func doInit(t *initTask) {
	switch t.state {
	case 2: // fully initialized
		return
	case 1: // initialization in progress
		throw("recursive call during initialization - linker skew")
	default: // not initialized yet

		// 修改状态
		t.state = 1
		
		// 通过 t.ndeps 获取依赖包数量
		for i := uintptr(0); i < t.ndeps; i++ {
			// 通过偏移量，获取地址
			p := add(unsafe.Pointer(t), (3+i)*sys.PtrSize)
			t2 := *(**initTask)(p)

			// 递归依赖包初始化
			doInit(t2)
		}

		// 通过 initTask.nfns 获取当前包初始化函数量
		for i := uintptr(0); i < t.nfns; i++ {
			// 计算偏移量，获取地址
			p := add(unsafe.Pointer(t), (3+t.ndeps+i)*sys.PtrSize)

			// 转换为函数类型,执行初始化函数
			f := *(*func())(unsafe.Pointer(&p))
			f()
		}

		// 初始化完成
		t.state = 2
	}
}
```

